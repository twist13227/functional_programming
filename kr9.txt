1) Функции foldl и ormap принимают в качестве одного из аргументов функцию => являются функциями высшего порядка

(foldl proc init lst ...+) → any/c

  proc : procedure?
  init : any/c
  lst : list?
foldl - это функция левоассоциативной свёртки, которая применяет заданную процедуру к элементам одного или нескольких списков слева направо (от головы к хвосту) и аккумулирует результат. Она принимает три аргумента: функцию (определяющую то, как возвращаемые значения будут объединяться), начальное значение аккумулятора (в него впоследствии будет записываться результат) и список элементов, к которым она применяется. Например, (foldl + 0 '(1 2 3 4)) вернет результат сложения всех элементов списка, то есть 10.
Если foldl вызывается с n списками, то proc должна принимать n+1 аргумент. Дополнительный аргумент - это объединенные на данный момент возвращаемые значения.
Изначально proc вызывается с первым элементом каждого списка, а последним аргументом является init. При последующих вызовах proc последним аргументом является возвращаемое значение из предыдущего вызова proc. Входные списки lst обходятся слева направо, и результатом всего применения foldl является результат последнего применения proc. Если lsts пусты, то результатом будет init.
Обрабатывает lsts за константное время 

(ormap proc lst ...+) → any

  proc : procedure?
  lst : list?
ormap - это функция, которая применяет заданную функцию к элементам списка и возвращает первый не #f, если хотя бы один из элементов удовлетворяет условию (получено не #f), и #f (ложь) в противном случае. Например, (ormap even? '(1 2 3 4)) вернет #t, так как в списке есть чётное число (2).

Касательно реализации ormap с использованием foldl: это невозможно, поскольку ormap не может принимать произвольное число списков на вход, в то время как foldl - да, и при использовании (lambda args <тело>) у нас получается список списков.

2) "Синтаксический сахар" - это концепция в языках программирования, которая описывает удобные синтаксические конструкции или сокращения, предназначенные для упрощения написания кода и повышения его читаемости, но не вносящие фундаментальных изменений в язык.

Пример "синтаксического сахара" в языке Scheme - это использование `define` для создания функций. Вместо написания `(lambda (x) (* x x))`, вы можете использовать более краткую запись `(define (square x) (* x x))`. Это делает код более понятным и легкочитаемым. Так же примером является спецформа let

Доводы "против" использования "синтаксического сахара":

1. Усложнение языка: Добавление большого количества синтаксического сахара может усложнить язык и сделать его менее предсказуемым для новых разработчиков, которые могут не знать или не понимать все сокращения.

2. Потеря универсальности: При слишком большом количестве синтаксического сахара язык может стать менее универсальным, потому что не все функции и возможности могут иметь сокращенную форму. Это может привести к тому, что разработчики могут ограничивать себя в выборе конструкций.

3. Повышение сложности для анализа кода: Некоторые виды синтаксического сахара могут затруднять анализ кода сторонними инструментами, такими как статические анализаторы или инструменты для автоматического тестирования.


